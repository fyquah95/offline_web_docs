var search_data = {"index":{"searchIndex":["minitest","assertion","assertions","expectations","mock","skip","spec","dsl","unit","guard","lifecyclehooks","testcase","minitest","unit","testcase","object","paralleleach","prideio","pridelol","_old_run_suites()","_run_suites()","after_setup()","after_teardown()","assert()","assert_empty()","assert_equal()","assert_in_delta()","assert_in_epsilon()","assert_includes()","assert_instance_of()","assert_kind_of()","assert_match()","assert_nil()","assert_operator()","assert_output()","assert_performance()","assert_performance_constant()","assert_performance_exponential()","assert_performance_linear()","assert_performance_logarithmic()","assert_performance_power()","assert_predicate()","assert_raises()","assert_respond_to()","assert_same()","assert_send()","assert_silent()","assert_throws()","before_setup()","before_teardown()","bench_exp()","bench_linear()","bench_range()","benchmark_suites()","capture_io()","capture_subprocess_io()","count()","diff()","diff()","diff=()","each()","exception_details()","expect()","fit_error()","fit_exponential()","fit_linear()","fit_logarithmic()","fit_power()","flunk()","i_suck_and_my_tests_are_order_dependent!()","io()","io?()","jruby?()","maglev?()","make_my_diffs_pretty!()","message()","mri?()","mu_pp()","mu_pp_for_diff()","must_be()","must_be_close_to()","must_be_empty()","must_be_instance_of()","must_be_kind_of()","must_be_nil()","must_be_same_as()","must_be_silent()","must_be_within_delta()","must_be_within_epsilon()","must_equal()","must_include()","must_match()","must_output()","must_raise()","must_respond_to()","must_send()","must_throw()","new()","parallelize_me!()","pass()","passed?()","pride()","pride()","print()","refute()","refute_empty()","refute_equal()","refute_in_delta()","refute_in_epsilon()","refute_includes()","refute_instance_of()","refute_kind_of()","refute_match()","refute_nil()","refute_operator()","refute_predicate()","refute_respond_to()","refute_same()","rubinius?()","run()","setup()","sigma()","size()","skip()","skipped?()","synchronize()","teardown()","validation_for_fit()","verify()","windows?()","wont_be()","wont_be_close_to()","wont_be_empty()","wont_be_instance_of()","wont_be_kind_of()","wont_be_nil()","wont_be_same_as()","wont_be_within_delta()","wont_be_within_epsilon()","wont_equal()","wont_include()","wont_match()","wont_respond_to()"],"longSearchIndex":["minitest","minitest::assertion","minitest::assertions","minitest::expectations","minitest::mock","minitest::skip","minitest::spec","minitest::spec::dsl","minitest::unit","minitest::unit::guard","minitest::unit::lifecyclehooks","minitest::unit::testcase","minitest","minitest::unit","minitest::unit::testcase","object","paralleleach","prideio","pridelol","minitest::unit#_old_run_suites()","minitest::unit#_run_suites()","minitest::unit::lifecyclehooks#after_setup()","minitest::unit::lifecyclehooks#after_teardown()","minitest::assertions#assert()","minitest::assertions#assert_empty()","minitest::assertions#assert_equal()","minitest::assertions#assert_in_delta()","minitest::assertions#assert_in_epsilon()","minitest::assertions#assert_includes()","minitest::assertions#assert_instance_of()","minitest::assertions#assert_kind_of()","minitest::assertions#assert_match()","minitest::assertions#assert_nil()","minitest::assertions#assert_operator()","minitest::assertions#assert_output()","minitest::unit::testcase#assert_performance()","minitest::unit::testcase#assert_performance_constant()","minitest::unit::testcase#assert_performance_exponential()","minitest::unit::testcase#assert_performance_linear()","minitest::unit::testcase#assert_performance_logarithmic()","minitest::unit::testcase#assert_performance_power()","minitest::assertions#assert_predicate()","minitest::assertions#assert_raises()","minitest::assertions#assert_respond_to()","minitest::assertions#assert_same()","minitest::assertions#assert_send()","minitest::assertions#assert_silent()","minitest::assertions#assert_throws()","minitest::unit::lifecyclehooks#before_setup()","minitest::unit::lifecyclehooks#before_teardown()","minitest::unit::testcase::bench_exp()","minitest::unit::testcase::bench_linear()","minitest::unit::testcase::bench_range()","minitest::unit::testcase::benchmark_suites()","minitest::assertions#capture_io()","minitest::assertions#capture_subprocess_io()","paralleleach#count()","minitest::assertions#diff()","minitest::assertions::diff()","minitest::assertions::diff=()","paralleleach#each()","minitest::assertions#exception_details()","minitest::mock#expect()","minitest::unit::testcase#fit_error()","minitest::unit::testcase#fit_exponential()","minitest::unit::testcase#fit_linear()","minitest::unit::testcase#fit_logarithmic()","minitest::unit::testcase#fit_power()","minitest::assertions#flunk()","minitest::unit::testcase::i_suck_and_my_tests_are_order_dependent!()","minitest::unit::testcase#io()","minitest::unit::testcase#io?()","minitest::unit::guard#jruby?()","minitest::unit::guard::maglev?()","minitest::unit::testcase::make_my_diffs_pretty!()","minitest::assertions#message()","minitest::unit::guard#mri?()","minitest::assertions#mu_pp()","minitest::assertions#mu_pp_for_diff()","minitest::expectations#must_be()","minitest::expectations#must_be_close_to()","minitest::expectations#must_be_empty()","minitest::expectations#must_be_instance_of()","minitest::expectations#must_be_kind_of()","minitest::expectations#must_be_nil()","minitest::expectations#must_be_same_as()","minitest::expectations#must_be_silent()","minitest::expectations#must_be_within_delta()","minitest::expectations#must_be_within_epsilon()","minitest::expectations#must_equal()","minitest::expectations#must_include()","minitest::expectations#must_match()","minitest::expectations#must_output()","minitest::expectations#must_raise()","minitest::expectations#must_respond_to()","minitest::expectations#must_send()","minitest::expectations#must_throw()","paralleleach::new()","minitest::unit::testcase::parallelize_me!()","minitest::assertions#pass()","minitest::unit::testcase#passed?()","prideio#pride()","pridelol#pride()","prideio#print()","minitest::assertions#refute()","minitest::assertions#refute_empty()","minitest::assertions#refute_equal()","minitest::assertions#refute_in_delta()","minitest::assertions#refute_in_epsilon()","minitest::assertions#refute_includes()","minitest::assertions#refute_instance_of()","minitest::assertions#refute_kind_of()","minitest::assertions#refute_match()","minitest::assertions#refute_nil()","minitest::assertions#refute_operator()","minitest::assertions#refute_predicate()","minitest::assertions#refute_respond_to()","minitest::assertions#refute_same()","minitest::unit::guard#rubinius?()","minitest::unit::testcase#run()","minitest::unit::testcase#setup()","minitest::unit::testcase#sigma()","paralleleach#size()","minitest::assertions#skip()","minitest::assertions#skipped?()","minitest::assertions#synchronize()","minitest::unit::testcase#teardown()","minitest::unit::testcase#validation_for_fit()","minitest::mock#verify()","minitest::unit::guard#windows?()","minitest::expectations#wont_be()","minitest::expectations#wont_be_close_to()","minitest::expectations#wont_be_empty()","minitest::expectations#wont_be_instance_of()","minitest::expectations#wont_be_kind_of()","minitest::expectations#wont_be_nil()","minitest::expectations#wont_be_same_as()","minitest::expectations#wont_be_within_delta()","minitest::expectations#wont_be_within_epsilon()","minitest::expectations#wont_equal()","minitest::expectations#wont_include()","minitest::expectations#wont_match()","minitest::expectations#wont_respond_to()"],"info":[["MiniTest","","MiniTest.html","","<p>Minimal (mostly drop-in) replacement for test-unit.\n<p>minitest/{unit,spec,mock,benchmark}\n<p>home  &mdash; github.com/seattlerb/minitest …\n"],["MiniTest::Assertion","","MiniTest/Assertion.html","","<p>Assertion base class\n"],["MiniTest::Assertions","","MiniTest/Assertions.html","","<p>MiniTest Assertions.  All assertion methods accept a <code>msg</code> which\nis printed if the assertion fails.\n"],["MiniTest::Expectations","","MiniTest/Expectations.html","","<p>It’s where you hide your “assertions”.\n"],["MiniTest::Mock","","MiniTest/Mock.html","","<p>All mock objects are an instance of Mock\n"],["MiniTest::Skip","","MiniTest/Skip.html","","<p>Assertion raised when skipping a test\n"],["MiniTest::Spec","","MiniTest/Spec.html","",""],["MiniTest::Spec::DSL","","MiniTest/Spec/DSL.html","",""],["MiniTest::Unit","","MiniTest/Unit.html","",""],["MiniTest::Unit::Guard","","MiniTest/Unit/Guard.html","","<p>Provides a simple set of guards that you can use in your tests to skip\nexecution if it is not applicable. …\n"],["MiniTest::Unit::LifecycleHooks","","MiniTest/Unit/LifecycleHooks.html","","<p>Provides before/after hooks for setup and teardown. These are meant for\nlibrary writers, NOT for regular …\n"],["MiniTest::Unit::TestCase","","MiniTest/Unit/TestCase.html","","<p>Subclass TestCase to create your own tests. Typically you’ll want a\nTestCase subclass per implementation …\n"],["Minitest","","Minitest.html","",""],["Minitest::Unit","","Minitest/Unit.html","",""],["Minitest::Unit::TestCase","","Minitest/Unit/TestCase.html","",""],["Object","","Object.html","",""],["ParallelEach","","ParallelEach.html","","<p>Provides a parallel #each that lets you enumerate using N threads. Use\nenvironment variable N to customize. …\n"],["PrideIO","","PrideIO.html","","<p>Show your testing pride!\n"],["PrideLOL","","PrideLOL.html","","<p>If you thought the PrideIO was colorful…\n<p>(Inspired by lolcat, but with clean math)\n"],["_old_run_suites","MiniTest::Unit","MiniTest/Unit.html#method-i-_old_run_suites","(suites, type)",""],["_run_suites","MiniTest::Unit","MiniTest/Unit.html#method-i-_run_suites","(suites, type)","<p>Runs all the <code>suites</code> for a given <code>type</code>. Runs suites\ndeclaring a test_order of <code>:parallel</code> in parallel, and …\n"],["after_setup","MiniTest::Unit::LifecycleHooks","MiniTest/Unit/LifecycleHooks.html#method-i-after_setup","()","<p>Runs before every test, after setup. This hook is meant for libraries to\nextend minitest. It is not meant …\n"],["after_teardown","MiniTest::Unit::LifecycleHooks","MiniTest/Unit/LifecycleHooks.html#method-i-after_teardown","()","<p>Runs after every test, after teardown. This hook is meant for libraries to\nextend minitest. It is not …\n"],["assert","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert","(test, msg = nil)","<p>Fails unless <code>test</code> is a true value.\n"],["assert_empty","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_empty","(obj, msg = nil)","<p>Fails unless <code>obj</code> is empty.\n"],["assert_equal","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_equal","(exp, act, msg = nil)","<p>Fails unless <code>exp == act</code> printing the difference between the\ntwo, if possible.\n<p>If there is no visible difference …\n"],["assert_in_delta","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_in_delta","(exp, act, delta = 0.001, msg = nil)","<p>For comparing Floats.  Fails unless <code>exp</code> and <code>act</code>\nare within <code>delta</code> of each other.\n\n<pre>assert_in_delta Math::PI, ...</pre>\n"],["assert_in_epsilon","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_in_epsilon","(a, b, epsilon = 0.001, msg = nil)","<p>For comparing Floats.  Fails unless <code>exp</code> and <code>act</code>\nhave a relative error less than <code>epsilon</code>.\n"],["assert_includes","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_includes","(collection, obj, msg = nil)","<p>Fails unless <code>collection</code> includes <code>obj</code>.\n"],["assert_instance_of","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_instance_of","(cls, obj, msg = nil)","<p>Fails unless <code>obj</code> is an instance of <code>cls</code>.\n"],["assert_kind_of","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_kind_of","(cls, obj, msg = nil)","<p>Fails unless <code>obj</code> is a kind of <code>cls</code>.\n"],["assert_match","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_match","(matcher, obj, msg = nil)","<p>Fails unless <code>matcher</code> <code>=~</code> <code>obj</code>.\n"],["assert_nil","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_nil","(obj, msg = nil)","<p>Fails unless <code>obj</code> is nil\n"],["assert_operator","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_operator","(o1, op, o2 = UNDEFINED, msg = nil)","<p>For testing with binary operators.\n\n<pre>assert_operator 5, :&lt;=, 4</pre>\n"],["assert_output","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_output","(stdout = nil, stderr = nil)","<p>Fails if stdout or stderr do not output the expected results. Pass in nil\nif you don’t care about that …\n"],["assert_performance","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-assert_performance","(validation, &work)","<p>Runs the given <code>work</code>, gathering the times of each run. Range\nand times are then passed to a given <code>validation</code> …\n"],["assert_performance_constant","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-assert_performance_constant","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered fit to\nmatch a constant rate (eg, linear slope …\n"],["assert_performance_exponential","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-assert_performance_exponential","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered fit to\nmatch a exponential curve within a given …\n"],["assert_performance_linear","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-assert_performance_linear","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered fit to\nmatch a straight line within a given error …\n"],["assert_performance_logarithmic","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-assert_performance_logarithmic","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered fit to\nmatch a logarithmic curve within a given …\n"],["assert_performance_power","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-assert_performance_power","(threshold = 0.99, &work)","<p>Runs the given <code>work</code> and asserts that the times gathered curve\nfit to match a power curve within a given …\n"],["assert_predicate","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_predicate","(o1, op, msg = nil)","<p>For testing with predicates.\n\n<pre>assert_predicate str, :empty?</pre>\n<p>This is really meant for specs and is front-ended …\n"],["assert_raises","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_raises","(*exp)","<p>Fails unless the block raises one of <code>exp</code>. Returns the\nexception matched so you can check the message, …\n"],["assert_respond_to","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_respond_to","(obj, meth, msg = nil)","<p>Fails unless <code>obj</code> responds to <code>meth</code>.\n"],["assert_same","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_same","(exp, act, msg = nil)","<p>Fails unless <code>exp</code> and <code>act</code> are #equal?\n"],["assert_send","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_send","(send_ary, m = nil)","<p><code>send_ary</code> is a receiver, message and arguments.\n<p>Fails unless the call returns a true value TODO: I should …\n"],["assert_silent","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_silent","()","<p>Fails if the block outputs anything to stderr or stdout.\n<p>See also: #assert_output\n"],["assert_throws","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_throws","(sym, msg = nil)","<p>Fails unless the block throws <code>sym</code>\n"],["before_setup","MiniTest::Unit::LifecycleHooks","MiniTest/Unit/LifecycleHooks.html#method-i-before_setup","()","<p>Runs before every test, before setup. This hook is meant for libraries to\nextend minitest. It is not …\n"],["before_teardown","MiniTest::Unit::LifecycleHooks","MiniTest/Unit/LifecycleHooks.html#method-i-before_teardown","()","<p>Runs after every test, before teardown. This hook is meant for libraries to\nextend minitest. It is not …\n"],["bench_exp","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-bench_exp","(min, max, base = 10)","<p>Returns a set of ranges stepped exponentially from <code>min</code> to\n<code>max</code> by powers of <code>base</code>. Eg:\n\n<pre>bench_exp(2, 16, ...</pre>\n"],["bench_linear","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-bench_linear","(min, max, step = 10)","<p>Returns a set of ranges stepped linearly from <code>min</code> to\n<code>max</code> by <code>step</code>. Eg:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">bench_linear</span>(<span class=\"ruby-value\">20</span>, <span class=\"ruby-value\">40</span>, <span class=\"ruby-value\">10</span>) <span class=\"ruby-comment\"># =&gt; [20, ...</span>\n</pre>\n"],["bench_range","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-bench_range","()","<p>Specifies the ranges used for benchmarking for that class. Defaults to\nexponential growth from 1 to 10k …\n"],["benchmark_suites","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-benchmark_suites","()","<p>Returns all test suites that have benchmark methods.\n"],["capture_io","MiniTest::Assertions","MiniTest/Assertions.html#method-i-capture_io","()","<p>Captures $stdout and $stderr into strings:\n\n<pre>out, err = capture_io do\n  puts &quot;Some info&quot;\n  warn &quot;You did ...</pre>\n"],["capture_subprocess_io","MiniTest::Assertions","MiniTest/Assertions.html#method-i-capture_subprocess_io","()","<p>Captures $stdout and $stderr into strings, using Tempfile to ensure that\nsubprocess IO is captured as …\n"],["count","ParallelEach","ParallelEach.html#method-i-count","()",""],["diff","MiniTest::Assertions","MiniTest/Assertions.html#method-i-diff","(exp, act)","<p>Returns a diff between <code>exp</code> and <code>act</code>. If there is\nno known diff command or if it doesn’t make sense to …\n"],["diff","MiniTest::Assertions","MiniTest/Assertions.html#method-c-diff","()","<p>Returns the diff command to use in #diff. Tries to intelligently figure out\nwhat diff to use.\n"],["diff=","MiniTest::Assertions","MiniTest/Assertions.html#method-c-diff-3D","(o)","<p>Set the diff command to use in #diff.\n"],["each","ParallelEach","ParallelEach.html#method-i-each","()","<p>Starts N threads that yield each element to your block. Joins the threads\nat the end.\n"],["exception_details","MiniTest::Assertions","MiniTest/Assertions.html#method-i-exception_details","(e, msg)","<p>Returns details for exception <code>e</code>\n"],["expect","MiniTest::Mock","MiniTest/Mock.html#method-i-expect","(name, retval, args=[], &blk)","<p>Expect that method <code>name</code> is called, optionally with\n<code>args</code> or a <code>blk</code>, and returns <code>retval</code>.\n\n<pre>@mock.expect(:meaning_of_life, ...</pre>\n"],["fit_error","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-fit_error","(xys)","<p>Takes an array of x/y pairs and calculates the general R^2 value.\n<p>See: en.wikipedia.org/wiki/Coefficient_of_determination …\n"],["fit_exponential","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-fit_exponential","(xs, ys)","<p>To fit a functional form: y = ae^(bx).\n<p>Takes x and y values and returns [a, b, r^2].\n<p>See: mathworld.wolfram.com/LeastSquaresFittingExponential.html …\n"],["fit_linear","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-fit_linear","(xs, ys)","<p>Fits the functional form: a + bx.\n<p>Takes x and y values and returns [a, b, r^2].\n<p>See: mathworld.wolfram.com/LeastSquaresFitting.html …\n"],["fit_logarithmic","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-fit_logarithmic","(xs, ys)","<p>To fit a functional form: y = a + b*ln(x).\n<p>Takes x and y values and returns [a, b, r^2].\n<p>See: mathworld.wolfram.com/LeastSquaresFittingLogarithmic.html …\n"],["fit_power","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-fit_power","(xs, ys)","<p>To fit a functional form: y = ax^b.\n<p>Takes x and y values and returns [a, b, r^2].\n<p>See: mathworld.wolfram.com/LeastSquaresFittingPowerLaw.html …\n"],["flunk","MiniTest::Assertions","MiniTest/Assertions.html#method-i-flunk","(msg = nil)","<p>Fails with <code>msg</code>\n"],["i_suck_and_my_tests_are_order_dependent!","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-i_suck_and_my_tests_are_order_dependent-21","()","<p>Call this at the top of your tests when you absolutely positively need to\nhave ordered tests. In doing …\n"],["io","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-io","()","<p>Return the output IO object\n"],["io?","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-io-3F","()","<p>Have we hooked up the IO yet?\n"],["jruby?","MiniTest::Unit::Guard","MiniTest/Unit/Guard.html#method-i-jruby-3F","(platform = RUBY_PLATFORM)","<p>Is this running on jruby?\n"],["maglev?","MiniTest::Unit::Guard","MiniTest/Unit/Guard.html#method-c-maglev-3F","(platform = defined?(RUBY_ENGINE) && RUBY_ENGINE)","<p>Is this running on mri?\n"],["make_my_diffs_pretty!","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-make_my_diffs_pretty-21","()","<p>Make diffs for this TestCase use #pretty_inspect so that diff in\nassert_equal can be more details. NOTE: …\n"],["message","MiniTest::Assertions","MiniTest/Assertions.html#method-i-message","(msg = nil, ending = \".\", &default)","<p>Returns a proc that will output <code>msg</code> along with the default\nmessage.\n"],["mri?","MiniTest::Unit::Guard","MiniTest/Unit/Guard.html#method-i-mri-3F","(platform = RUBY_DESCRIPTION)","<p>Is this running on mri?\n"],["mu_pp","MiniTest::Assertions","MiniTest/Assertions.html#method-i-mu_pp","(obj)","<p>This returns a human-readable version of <code>obj</code>. By default\n#inspect is called. You can override this to …\n"],["mu_pp_for_diff","MiniTest::Assertions","MiniTest/Assertions.html#method-i-mu_pp_for_diff","(obj)","<p>This returns a diff-able human-readable version of <code>obj</code>. This\ndiffers from the regular mu_pp because it …\n"],["must_be","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be","","<p>See MiniTest::Assertions#assert_operator\n\n<pre>n.must_be :&lt;=, 42</pre>\n<p>This can also do predicates:\n"],["must_be_close_to","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_close_to","","<p>See MiniTest::Assertions#assert_in_delta\n\n<pre>n.must_be_close_to m [, delta]</pre>\n"],["must_be_empty","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_empty","","<p>See MiniTest::Assertions#assert_empty.\n\n<pre>collection.must_be_empty</pre>\n"],["must_be_instance_of","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_instance_of","","<p>See MiniTest::Assertions#assert_instance_of\n\n<pre>obj.must_be_instance_of klass</pre>\n"],["must_be_kind_of","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_kind_of","","<p>See MiniTest::Assertions#assert_kind_of\n\n<pre>obj.must_be_kind_of mod</pre>\n"],["must_be_nil","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_nil","","<p>See MiniTest::Assertions#assert_nil\n\n<pre>obj.must_be_nil</pre>\n"],["must_be_same_as","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_same_as","","<p>See MiniTest::Assertions#assert_same\n\n<pre>a.must_be_same_as b</pre>\n"],["must_be_silent","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_silent","","<p>See MiniTest::Assertions#assert_silent\n\n<pre>proc { ... }.must_be_silent</pre>\n"],["must_be_within_delta","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_within_delta","",""],["must_be_within_epsilon","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_be_within_epsilon","","<p>See MiniTest::Assertions#assert_in_epsilon\n\n<pre>n.must_be_within_epsilon m [, epsilon]</pre>\n"],["must_equal","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_equal","","<p>See MiniTest::Assertions#assert_equal\n\n<pre>a.must_equal b</pre>\n"],["must_include","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_include","","<p>See MiniTest::Assertions#assert_includes\n\n<pre>collection.must_include obj</pre>\n"],["must_match","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_match","","<p>See MiniTest::Assertions#assert_match\n\n<pre>a.must_match b</pre>\n"],["must_output","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_output","","<p>See MiniTest::Assertions#assert_output\n\n<pre>proc { ... }.must_output out_or_nil [, err]</pre>\n"],["must_raise","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_raise","","<p>See MiniTest::Assertions#assert_raises\n\n<pre>proc { ... }.must_raise exception</pre>\n"],["must_respond_to","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_respond_to","","<p>See MiniTest::Assertions#assert_respond_to\n\n<pre>obj.must_respond_to msg</pre>\n"],["must_send","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_send","","<p>See MiniTest::Assertions#assert_send TODO: remove me\n\n<pre>a.must_send</pre>\n"],["must_throw","MiniTest::Expectations","MiniTest/Expectations.html#method-i-must_throw","","<p>See MiniTest::Assertions#assert_throws\n\n<pre>proc { ... }.must_throw sym</pre>\n"],["new","ParallelEach","ParallelEach.html#method-c-new","(list)","<p>Create a new ParallelEach instance over <code>list</code>.\n"],["parallelize_me!","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-parallelize_me-21","()","<p>Call this at the top of your tests when you want to run your tests in\nparallel. In doing so, you’re admitting …\n"],["pass","MiniTest::Assertions","MiniTest/Assertions.html#method-i-pass","(msg = nil)","<p>used for counting assertions\n"],["passed?","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-passed-3F","()","<p>Returns true if the test passed.\n"],["pride","PrideIO","PrideIO.html#method-i-pride","(string)","<p>Color a string.\n"],["pride","PrideLOL","PrideLOL.html#method-i-pride","(string)","<p>Make the string even more colorful. Damnit.\n"],["print","PrideIO","PrideIO.html#method-i-print","(o)","<p>Wrap print to colorize the output.\n"],["refute","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute","(test, msg = nil)","<p>Fails if <code>test</code> is a true value\n"],["refute_empty","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_empty","(obj, msg = nil)","<p>Fails if <code>obj</code> is empty.\n"],["refute_equal","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_equal","(exp, act, msg = nil)","<p>Fails if <code>exp == act</code>.\n<p>For floats use refute_in_delta.\n"],["refute_in_delta","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_in_delta","(exp, act, delta = 0.001, msg = nil)","<p>For comparing Floats.  Fails if <code>exp</code> is within\n<code>delta</code> of <code>act</code>.\n\n<pre>refute_in_delta Math::PI, (22.0 / 7.0)</pre>\n"],["refute_in_epsilon","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_in_epsilon","(a, b, epsilon = 0.001, msg = nil)","<p>For comparing Floats.  Fails if <code>exp</code> and <code>act</code> have\na relative error less than <code>epsilon</code>.\n"],["refute_includes","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_includes","(collection, obj, msg = nil)","<p>Fails if <code>collection</code> includes <code>obj</code>.\n"],["refute_instance_of","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_instance_of","(cls, obj, msg = nil)","<p>Fails if <code>obj</code> is an instance of <code>cls</code>.\n"],["refute_kind_of","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_kind_of","(cls, obj, msg = nil)","<p>Fails if <code>obj</code> is a kind of <code>cls</code>.\n"],["refute_match","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_match","(matcher, obj, msg = nil)","<p>Fails if <code>matcher</code> <code>=~</code> <code>obj</code>.\n"],["refute_nil","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_nil","(obj, msg = nil)","<p>Fails if <code>obj</code> is nil.\n"],["refute_operator","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_operator","(o1, op, o2 = UNDEFINED, msg = nil)","<p>Fails if <code>o1</code> is not <code>op</code> <code>o2</code>. Eg:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">refute_operator</span> <span class=\"ruby-value\">1</span>, :<span class=\"ruby-operator\">&gt;</span>, <span class=\"ruby-value\">2</span> <span class=\"ruby-comment\">#=&gt; pass</span>\n<span class=\"ruby-identifier\">refute_operator</span> <span class=\"ruby-value\">1</span>, :<span class=\"ruby-operator\">&lt;</span>, <span class=\"ruby-value\">2</span> <span class=\"ruby-comment\">#=&gt; fail</span>\n</pre>\n"],["refute_predicate","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_predicate","(o1, op, msg = nil)","<p>For testing with predicates.\n\n<pre>refute_predicate str, :empty?</pre>\n<p>This is really meant for specs and is front-ended …\n"],["refute_respond_to","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_respond_to","(obj, meth, msg = nil)","<p>Fails if <code>obj</code> responds to the message <code>meth</code>.\n"],["refute_same","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_same","(exp, act, msg = nil)","<p>Fails if <code>exp</code> is the same (by object identity) as\n<code>act</code>.\n"],["rubinius?","MiniTest::Unit::Guard","MiniTest/Unit/Guard.html#method-i-rubinius-3F","(platform = defined?(RUBY_ENGINE) && RUBY_ENGINE)","<p>Is this running on rubinius?\n"],["run","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-run","(runner)","<p>Runs the tests reporting the status to <code>runner</code>\n"],["setup","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-setup","()","<p>Runs before every test. Use this to set up before each test run.\n"],["sigma","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-sigma","(enum, &block)","<p>Enumerates over <code>enum</code> mapping <code>block</code> if given,\nreturning the sum of the result. Eg:\n\n<pre>sigma([1, 2, 3])    ...</pre>\n"],["size","ParallelEach","ParallelEach.html#method-i-size","()",""],["skip","MiniTest::Assertions","MiniTest/Assertions.html#method-i-skip","(msg = nil, bt = caller)","<p>Skips the current test. Gets listed at the end of the run but doesn’t cause\na failure exit code.\n"],["skipped?","MiniTest::Assertions","MiniTest/Assertions.html#method-i-skipped-3F","()","<p>Was this testcase skipped? Meant for #teardown.\n"],["synchronize","MiniTest::Assertions","MiniTest/Assertions.html#method-i-synchronize","()","<p>Takes a block and wraps it with the runner’s shared mutex.\n"],["teardown","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-teardown","()","<p>Runs after every test. Use this to clean up after each test run.\n"],["validation_for_fit","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-validation_for_fit","(msg, threshold)","<p>Returns a proc that calls the specified fit method and asserts that the\nerror is within a tolerable threshold. …\n"],["verify","MiniTest::Mock","MiniTest/Mock.html#method-i-verify","()","<p>Verify that all methods were called as expected. Raises\n<code>MockExpectationError</code> if the mock object was not …\n"],["windows?","MiniTest::Unit::Guard","MiniTest/Unit/Guard.html#method-i-windows-3F","(platform = RUBY_PLATFORM)","<p>Is this running on windows?\n"],["wont_be","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be","","<p>See MiniTest::Assertions#refute_operator\n\n<pre>n.wont_be :&lt;=, 42</pre>\n<p>This can also do predicates:\n"],["wont_be_close_to","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_close_to","","<p>See MiniTest::Assertions#refute_in_delta\n\n<pre>n.wont_be_close_to m [, delta]</pre>\n"],["wont_be_empty","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_empty","","<p>See MiniTest::Assertions#refute_empty\n\n<pre>collection.wont_be_empty</pre>\n"],["wont_be_instance_of","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_instance_of","","<p>See MiniTest::Assertions#refute_instance_of\n\n<pre>obj.wont_be_instance_of klass</pre>\n"],["wont_be_kind_of","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_kind_of","","<p>See MiniTest::Assertions#refute_kind_of\n\n<pre>obj.wont_be_kind_of mod</pre>\n"],["wont_be_nil","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_nil","","<p>See MiniTest::Assertions#refute_nil\n\n<pre>obj.wont_be_nil</pre>\n"],["wont_be_same_as","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_same_as","","<p>See MiniTest::Assertions#refute_same\n\n<pre>a.wont_be_same_as b</pre>\n"],["wont_be_within_delta","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_within_delta","",""],["wont_be_within_epsilon","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_be_within_epsilon","","<p>See MiniTest::Assertions#refute_in_epsilon\n\n<pre>n.wont_be_within_epsilon m [, epsilon]</pre>\n"],["wont_equal","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_equal","","<p>See MiniTest::Assertions#refute_equal\n\n<pre>a.wont_equal b</pre>\n"],["wont_include","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_include","","<p>See MiniTest::Assertions#refute_includes\n\n<pre>collection.wont_include obj</pre>\n"],["wont_match","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_match","","<p>See MiniTest::Assertions#refute_match\n\n<pre>a.wont_match b</pre>\n"],["wont_respond_to","MiniTest::Expectations","MiniTest/Expectations.html#method-i-wont_respond_to","","<p>See MiniTest::Assertions#refute_respond_to\n\n<pre>obj.wont_respond_to msg</pre>\n"]]}}