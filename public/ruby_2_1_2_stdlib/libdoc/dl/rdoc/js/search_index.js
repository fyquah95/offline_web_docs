var search_data = {"index":{"searchIndex":["dl","basictypes","cfunc","cparser","cptr","cstruct","cstructbuilder","cstructentity","cunion","cunionentity","carriedfunction","compositehandler","dlerror","dltypeerror","fiddle","function","handle","importer","packinfo","packer","stack","tempfunction","valueutil","win32types","object","+()","+@()","-()","-@()","<=>()","==()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]=()","[]=()","align()","assign_names()","bind()","bind()","bind_at_call()","bind_at_call()","bind_at_call()","bind_function()","bound?()","call()","call()","calltype()","calltype=()","close()","close_enabled?()","create()","create_carried_function()","create_carrier()","create_temp_function()","create_value()","ctype()","ctype=()","disable_close()","dlload()","dlopen()","dlunwrap()","dlwrap()","enable_close()","entity_class()","entity_class()","eql?()","extern()","fiddle?()","foreach_proc_entry()","free()","free()","free=()","func_name()","gen_callback_file()","gen_push_addr_ary()","gen_push_proc_ary()","gencallback()","handler()","handlers()","import_function()","import_symbol()","import_value()","inspect()","inspect()","last_error()","malloc()","malloc()","malloc()","malloc()","name()","name()","new()","new()","new()","new()","new()","new()","new()","new()","new()","null?()","pack()","pack()","parse_ctype()","parse_signature()","parse_struct_signature()","ptr()","ptr()","ptr=()","realloc()","ref()","remove_callback()","remove_callback_internal()","remove_cdecl_callback()","remove_stdcall_callback()","set_callback()","set_callback_internal()","set_cdecl_callback()","set_ctypes()","set_ctypes()","set_stdcall_callback()","signed_value()","size()","size()","size()","size()","size()","size=()","sizeof()","struct()","sym()","sym()","sym()","to_i()","to_i()","to_i()","to_i()","to_int()","to_ptr()","to_s()","to_s()","to_str()","to_value()","typealias()","types()","unbind()","unbind_at_call()","unbind_at_call()","union()","unpack()","unpack()","unsigned_value()","value()","win32_last_error()","wrap_arg()","wrap_args()","wrap_result()"],"longSearchIndex":["dl","dl::basictypes","dl::cfunc","dl::cparser","dl::cptr","dl::cstruct","dl::cstructbuilder","dl::cstructentity","dl::cunion","dl::cunionentity","dl::carriedfunction","dl::compositehandler","dl::dlerror","dl::dltypeerror","dl::fiddle","dl::function","dl::handle","dl::importer","dl::packinfo","dl::packer","dl::stack","dl::tempfunction","dl::valueutil","dl::win32types","object","dl::cptr#+()","dl::cptr#+@()","dl::cptr#-()","dl::cptr#-@()","dl::cptr#<=>()","dl::cptr#==()","dl::cfunc#[]()","dl::cptr#[]()","dl::cptr::[]()","dl::cstructentity#[]()","dl::compositehandler#[]()","dl::handle::[]()","dl::handle#[]()","dl::importer#[]()","dl::packer::[]()","dl::stack::[]()","dl::cptr#[]=()","dl::cstructentity#[]=()","dl::packinfo::align()","dl::cstructentity#assign_names()","dl::function#bind()","dl::importer#bind()","dl::carriedfunction#bind_at_call()","dl::function#bind_at_call()","dl::tempfunction#bind_at_call()","dl::importer#bind_function()","dl::function#bound?()","dl::cfunc#call()","dl::function#call()","dl::cfunc#calltype()","dl::cfunc#calltype=()","dl::handle#close()","dl::handle#close_enabled?()","dl::cstructbuilder::create()","dl::importer#create_carried_function()","dl::carriedfunction#create_carrier()","dl::importer#create_temp_function()","dl::importer#create_value()","dl::cfunc#ctype()","dl::cfunc#ctype=()","dl::handle#disable_close()","dl::importer#dlload()","dl::dlopen()","dl::dlunwrap()","dl::dlwrap()","dl::handle#enable_close()","dl::cstruct::entity_class()","dl::cunion::entity_class()","dl::cptr#eql?()","dl::importer#extern()","dl::fiddle?()","object#foreach_proc_entry()","dl::free()","dl::cptr#free()","dl::cptr#free=()","object#func_name()","object#gen_callback_file()","object#gen_push_addr_ary()","object#gen_push_proc_ary()","object#gencallback()","dl::importer#handler()","dl::compositehandler#handlers()","dl::importer#import_function()","dl::importer#import_symbol()","dl::importer#import_value()","dl::cfunc#inspect()","dl::cptr#inspect()","dl::cfunc::last_error()","dl::malloc()","dl::cptr::malloc()","dl::cstructentity::malloc()","dl::cunionentity::malloc()","dl::cfunc#name()","dl::function#name()","dl::cfunc::new()","dl::cptr::new()","dl::cstructentity::new()","dl::carriedfunction::new()","dl::compositehandler::new()","dl::function::new()","dl::handle::new()","dl::packer::new()","dl::stack::new()","dl::cptr#null?()","dl::packer#pack()","dl::stack#pack()","dl::cparser#parse_ctype()","dl::cparser#parse_signature()","dl::cparser#parse_struct_signature()","dl::cfunc#ptr()","dl::cptr#ptr()","dl::cfunc#ptr=()","dl::realloc()","dl::cptr#ref()","dl#remove_callback()","dl#remove_callback_internal()","dl#remove_cdecl_callback()","dl#remove_stdcall_callback()","dl#set_callback()","dl#set_callback_internal()","dl#set_cdecl_callback()","dl::cstructentity#set_ctypes()","dl::cunionentity#set_ctypes()","dl#set_stdcall_callback()","dl::valueutil#signed_value()","dl::cptr#size()","dl::cstructentity::size()","dl::cunionentity::size()","dl::packer#size()","dl::stack#size()","dl::cptr#size=()","dl::importer#sizeof()","dl::importer#struct()","dl::compositehandler#sym()","dl::handle#sym()","dl::handle::sym()","dl::cfunc#to_i()","dl::cptr#to_i()","dl::function#to_i()","dl::handle#to_i()","dl::cptr#to_int()","dl::cptr::to_ptr()","dl::cfunc#to_s()","dl::cptr#to_s()","dl::cptr#to_str()","dl::cptr#to_value()","dl::importer#typealias()","dl::stack#types()","dl::function#unbind()","dl::function#unbind_at_call()","dl::tempfunction#unbind_at_call()","dl::importer#union()","dl::packer#unpack()","dl::stack#unpack()","dl::valueutil#unsigned_value()","dl::importer#value()","dl::cfunc::win32_last_error()","dl::valueutil#wrap_arg()","dl::valueutil#wrap_args()","dl::function#wrap_result()"],"info":[["DL","","DL.html","","<p>A bridge to the dlopen() or dynamic library linker function.\n<p>Example\n\n<pre>bash $&gt; cat &gt; sum.c &lt;&lt;EOF\ndouble sum(double ...</pre>\n"],["DL::BasicTypes","","DL/BasicTypes.html","","<p>Adds basic type aliases to the including class for use with DL::Importer.\n<p>The aliases added are <code>uint</code> and …\n"],["DL::CFunc","","DL/CFunc.html","","<p>A direct accessor to a function in a C library\n<p>Example\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">libc_so</span> = <span class=\"ruby-string\">&quot;/lib64/libc.so.6&quot;</span>\n=<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-string\">&quot;/lib64/libc.so.6&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["DL::CParser","","DL/CParser.html","","<p>Methods for parsing C struct and C prototype signatures.\n"],["DL::CPtr","","DL/CPtr.html","","<p>CPtr is a class to handle C pointers\n"],["DL::CStruct","","DL/CStruct.html","","<p>C struct shell\n"],["DL::CStructBuilder","","DL/CStructBuilder.html","","<p>Used to construct C classes (CUnion, CStruct, etc)\n<p>DL::Importer#struct and DL::Importer#union wrap this …\n"],["DL::CStructEntity","","DL/CStructEntity.html","","<p>A C struct wrapper\n"],["DL::CUnion","","DL/CUnion.html","","<p>C union shell\n"],["DL::CUnionEntity","","DL/CUnionEntity.html","","<p>A C union wrapper\n"],["DL::CarriedFunction","","DL/CarriedFunction.html","",""],["DL::CompositeHandler","","DL/CompositeHandler.html","",""],["DL::DLError","","DL/DLError.html","","<p>standard dynamic load exception\n"],["DL::DLTypeError","","DL/DLTypeError.html","","<p>dynamic load incorrect type exception\n"],["DL::Fiddle","","DL/Fiddle.html","",""],["DL::Function","","DL/Function.html","",""],["DL::Handle","","DL/Handle.html","","<p>The DL::Handle is the manner to access the dynamic library\n<p>Example\n<p>Setup\n"],["DL::Importer","","DL/Importer.html","","<p>DL::Importer includes the means to dynamically load libraries and build\nmodules around them including …\n"],["DL::PackInfo","","DL/PackInfo.html","",""],["DL::Packer","","DL/Packer.html","",""],["DL::Stack","","DL/Stack.html","",""],["DL::TempFunction","","DL/TempFunction.html","",""],["DL::ValueUtil","","DL/ValueUtil.html","",""],["DL::Win32Types","","DL/Win32Types.html","","<p>Adds Windows type aliases to the including class for use with DL::Importer.\n<p>The aliases added are:\n<p>ATOM …\n"],["Object","","Object.html","",""],["+","DL::CPtr","DL/CPtr.html#method-i-2B","(p1)","<p>Returns a new DL::CPtr that has been advanced <code>n</code> bytes.\n"],["+@","DL::CPtr","DL/CPtr.html#method-i-2B-40","()","<p>Returns a DL::CPtr that is a dereferenced pointer for this DL::CPtr.\nAnalogous to the star operator in …\n"],["-","DL::CPtr","DL/CPtr.html#method-i-2D","(p1)","<p>Returns a new DL::CPtr that has been moved back <code>n</code> bytes.\n"],["-@","DL::CPtr","DL/CPtr.html#method-i-2D-40","()","<p>Returns a DL::CPtr that is a reference pointer for this DL::CPtr. Analogous\nto the ampersand operator …\n"],["<=>","DL::CPtr","DL/CPtr.html#method-i-3C-3D-3E","(p1)","<p>Returns -1 if less than, 0 if equal to, 1 if greater than\n<code>other</code>.  Returns nil if <code>ptr</code> cannot be compared …\n"],["==","DL::CPtr","DL/CPtr.html#method-i-3D-3D","(p1)","<p>Returns true if <code>other</code> wraps the same pointer, otherwise\nreturns false.\n"],["[]","DL::CFunc","DL/CFunc.html#method-i-5B-5D","(p1)","<p>Calls the function pointer passing in <code>ary</code> as values to the\nunderlying C function.  The return value depends …\n"],["[]","DL::CPtr","DL/CPtr.html#method-i-5B-5D","(p1, p2 = v2)","<p>Returns integer stored at <em>index</em>.  If <em>start</em> and\n<em>length</em> are given, a string containing the bytes from  …\n"],["[]","DL::CPtr","DL/CPtr.html#method-c-5B-5D","(p1)","<p>Get the underlying pointer for ruby object <code>val</code> and return it\nas a DL::CPtr object.\n"],["[]","DL::CStructEntity","DL/CStructEntity.html#method-i-5B-5D","(name)","<p>Fetch struct member <code>name</code>\n"],["[]","DL::CompositeHandler","DL/CompositeHandler.html#method-i-5B-5D","(symbol)",""],["[]","DL::Handle","DL/Handle.html#method-c-5B-5D","(p1)","<p>Get the address as an Integer for the function named <code>name</code>.\n"],["[]","DL::Handle","DL/Handle.html#method-i-5B-5D","(p1)","<p>Get the address as an Integer for the function named <code>name</code>.\n"],["[]","DL::Importer","DL/Importer.html#method-i-5B-5D","(name)",""],["[]","DL::Packer","DL/Packer.html#method-c-5B-5D","(*types)",""],["[]","DL::Stack","DL/Stack.html#method-c-5B-5D","(*types)",""],["[]=","DL::CPtr","DL/CPtr.html#method-i-5B-5D-3D","(p1, p2, p3 = v3)","<p>Set the value at <code>index</code> to <code>int</code>.  Or, set the\nmemory at <code>start</code> until <code>length</code> with the contents of\n<code>string</code> …\n"],["[]=","DL::CStructEntity","DL/CStructEntity.html#method-i-5B-5D-3D","(name, val)","<p>Set struct member <code>name</code>, to value <code>val</code>\n"],["align","DL::PackInfo","DL/PackInfo.html#method-c-align","(addr, align)",""],["assign_names","DL::CStructEntity","DL/CStructEntity.html#method-i-assign_names","(members)","<p>Set the names of the <code>members</code> in this C struct\n"],["bind","DL::Function","DL/Function.html#method-i-bind","(&block)",""],["bind","DL::Importer","DL/Importer.html#method-i-bind","(signature, *opts, &blk)",""],["bind_at_call","DL::CarriedFunction","DL/CarriedFunction.html#method-i-bind_at_call","(&block)",""],["bind_at_call","DL::Function","DL/Function.html#method-i-bind_at_call","(&block)",""],["bind_at_call","DL::TempFunction","DL/TempFunction.html#method-i-bind_at_call","(&block)",""],["bind_function","DL::Importer","DL/Importer.html#method-i-bind_function","(name, ctype, argtype, call_type = nil, &block)",""],["bound?","DL::Function","DL/Function.html#method-i-bound-3F","()",""],["call","DL::CFunc","DL/CFunc.html#method-i-call","(p1)","<p>Calls the function pointer passing in <code>ary</code> as values to the\nunderlying C function.  The return value depends …\n"],["call","DL::Function","DL/Function.html#method-i-call","(*args, &block)",""],["calltype","DL::CFunc","DL/CFunc.html#method-i-calltype","()","<p>Get the call type of this function.\n"],["calltype=","DL::CFunc","DL/CFunc.html#method-i-calltype-3D","(p1)","<p>Set the call type for this function.\n"],["close","DL::Handle","DL/Handle.html#method-i-close","()","<p>Close this DL::Handle.  Calling close more than once will raise a\nDL::DLError exception.\n"],["close_enabled?","DL::Handle","DL/Handle.html#method-i-close_enabled-3F","()","<p>Returns <code>true</code> if dlclose() will be called when this DL::Handle\nis garbage collected.\n"],["create","DL::CStructBuilder","DL/CStructBuilder.html#method-c-create","(klass, types, members)","<p>Construct a new class given a C:\n<p>class <code>klass</code> (CUnion, CStruct, or other that provide an\n#entity_class …\n"],["create_carried_function","DL::Importer","DL/Importer.html#method-i-create_carried_function","(name, ctype, argtype, call_type = nil, n = 0)",""],["create_carrier","DL::CarriedFunction","DL/CarriedFunction.html#method-i-create_carrier","(data)",""],["create_temp_function","DL::Importer","DL/Importer.html#method-i-create_temp_function","(name, ctype, argtype, call_type = nil)",""],["create_value","DL::Importer","DL/Importer.html#method-i-create_value","(ty, val=nil)",""],["ctype","DL::CFunc","DL/CFunc.html#method-i-ctype","()","<p>Get the C function return value type.  See DL for a list of constants\ncorresponding to this method’s …\n"],["ctype=","DL::CFunc","DL/CFunc.html#method-i-ctype-3D","(p1)","<p>Set the C function return value type to <code>type</code>.\n"],["disable_close","DL::Handle","DL/Handle.html#method-i-disable_close","()","<p>Disable a call to dlclose() when this DL::Handle is garbage collected.\n"],["dlload","DL::Importer","DL/Importer.html#method-i-dlload","(*libs)",""],["dlopen","DL","DL.html#method-c-dlopen","(*args)","<p>An interface to the dynamic linking loader\n<p>This is a shortcut to DL::Handle.new and takes the same arguments. …\n"],["dlunwrap","DL","DL.html#method-c-dlunwrap","(p1)","<p>Returns the hexadecimal representation of a memory pointer address\n<code>addr</code>\n<p>Example:\n\n<pre>lib = DL.dlopen('/lib64/libc-2.15.so') ...</pre>\n"],["dlwrap","DL","DL.html#method-c-dlwrap","(p1)","<p>Returns a memory pointer of a function’s hexadecimal address location\n<code>val</code>\n<p>Example:\n\n<pre>lib = DL.dlopen('/lib64/libc-2.15.so') ...</pre>\n"],["enable_close","DL::Handle","DL/Handle.html#method-i-enable_close","()","<p>Enable a call to dlclose() when this DL::Handle is garbage collected.\n"],["entity_class","DL::CStruct","DL/CStruct.html#method-c-entity_class","()","<p>accessor to DL::CStructEntity\n"],["entity_class","DL::CUnion","DL/CUnion.html#method-c-entity_class","()","<p>accessor to DL::CUnionEntity\n"],["eql?","DL::CPtr","DL/CPtr.html#method-i-eql-3F","(p1)","<p>Returns true if <code>other</code> wraps the same pointer, otherwise\nreturns false.\n"],["extern","DL::Importer","DL/Importer.html#method-i-extern","(signature, *opts)",""],["fiddle?","DL","DL.html#method-c-fiddle-3F","()","<p>Returns true if DL is using Fiddle, the libffi wrapper.\n"],["foreach_proc_entry","Object","Object.html#method-i-foreach_proc_entry","()",""],["free","DL","DL.html#method-c-free","(p1)","<p>Free the memory at address <code>addr</code>\n"],["free","DL::CPtr","DL/CPtr.html#method-i-free","()","<p>Get the free function for this pointer.  Returns  DL::CFunc or nil.\n"],["free=","DL::CPtr","DL/CPtr.html#method-i-free-3D","(p1)","<p>Set the free function for this pointer to the DL::CFunc in\n<code>function</code>.\n"],["func_name","Object","Object.html#method-i-func_name","(ty, argc, n, calltype)",""],["gen_callback_file","Object","Object.html#method-i-gen_callback_file","(ty)",""],["gen_push_addr_ary","Object","Object.html#method-i-gen_push_addr_ary","(ty, aryname, calltype)",""],["gen_push_proc_ary","Object","Object.html#method-i-gen_push_proc_ary","(ty, aryname)",""],["gencallback","Object","Object.html#method-i-gencallback","(ty, calltype, proc_entry, argc, n)",""],["handler","DL::Importer","DL/Importer.html#method-i-handler","()",""],["handlers","DL::CompositeHandler","DL/CompositeHandler.html#method-i-handlers","()",""],["import_function","DL::Importer","DL/Importer.html#method-i-import_function","(name, ctype, argtype, call_type = nil)",""],["import_symbol","DL::Importer","DL/Importer.html#method-i-import_symbol","(name)",""],["import_value","DL::Importer","DL/Importer.html#method-i-import_value","(ty, addr)",""],["inspect","DL::CFunc","DL/CFunc.html#method-i-inspect","()","<p>Returns a string formatted with an easily readable representation of the\ninternal state of the DL::CFunc …\n"],["inspect","DL::CPtr","DL/CPtr.html#method-i-inspect","()","<p>Returns a string formatted with an easily readable representation of the\ninternal state of the DL::CPtr …\n"],["last_error","DL::CFunc","DL/CFunc.html#method-c-last_error","()","<p>Returns the last error for the current executing thread\n"],["malloc","DL","DL.html#method-c-malloc","(p1)","<p>Allocate <code>size</code> bytes of memory and return the integer memory\naddress for the allocated memory.\n"],["malloc","DL::CPtr","DL/CPtr.html#method-c-malloc","(p1, p2 = v2)","<p>Allocate <code>size</code> bytes of memory and associate it with an\noptional <code>freefunc</code> that will be called when the …\n"],["malloc","DL::CStructEntity","DL/CStructEntity.html#method-c-malloc","(types, func = nil)","<p>Allocates a C struct the <code>types</code> provided.  The C function\n<code>func</code> is called when the instance is garbage …\n"],["malloc","DL::CUnionEntity","DL/CUnionEntity.html#method-c-malloc","(types, func=nil)","<p>Allocates a C union the <code>types</code> provided.  The C function\n<code>func</code> is called when the instance is garbage collected. …\n"],["name","DL::CFunc","DL/CFunc.html#method-i-name","()","<p>Get the name of this function\n"],["name","DL::Function","DL/Function.html#method-i-name","()",""],["new","DL::CFunc","DL/CFunc.html#method-c-new","(p1, p2 = v2, p3 = v3, p4 = v4)","<p>Create a new function that points to <code>address</code> with an optional\nreturn type of <code>type</code>, a name of <code>name</code> and …\n"],["new","DL::CPtr","DL/CPtr.html#method-c-new","(p1, p2 = v2, p3 = v3)","<p>Create a new pointer to <code>address</code> with an optional\n<code>size</code> and <code>freefunc</code>. <code>freefunc</code> will be\ncalled when the …\n"],["new","DL::CStructEntity","DL/CStructEntity.html#method-c-new","(addr, types, func = nil)","<p>Wraps the C pointer <code>addr</code> as a C struct with the given\n<code>types</code>.  The C function <code>func</code> is called when the …\n"],["new","DL::CarriedFunction","DL/CarriedFunction.html#method-c-new","(cfunc, argtypes, n)",""],["new","DL::CompositeHandler","DL/CompositeHandler.html#method-c-new","(handlers)",""],["new","DL::Function","DL/Function.html#method-c-new","(cfunc, argtypes, abi = nil, &block)",""],["new","DL::Handle","DL/Handle.html#method-c-new","(p1 = v1, p2 = v2)","<p>Create a new handler that opens library named <code>lib</code> with\n<code>flags</code>.  If no library is specified, RTLD_DEFAULT …\n"],["new","DL::Packer","DL/Packer.html#method-c-new","(types)",""],["new","DL::Stack","DL/Stack.html#method-c-new","(types)",""],["null?","DL::CPtr","DL/CPtr.html#method-i-null-3F","()","<p>Returns true if this is a null pointer.\n"],["pack","DL::Packer","DL/Packer.html#method-i-pack","(ary)",""],["pack","DL::Stack","DL/Stack.html#method-i-pack","(ary)",""],["parse_ctype","DL::CParser","DL/CParser.html#method-i-parse_ctype","(ty, tymap=nil)","<p>Given a String of C type <code>ty</code>, return the corresponding DL\nconstant.\n<p><code>ty</code> can also accept an Array of C type ...\n"],["parse_signature","DL::CParser","DL/CParser.html#method-i-parse_signature","(signature, tymap=nil)","<p>Parses a C prototype signature\n<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">include</span> <span class=\"ruby-constant\">DL</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">CParser</span>\n=<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-constant\">Object</span>\n\n<span class=\"ruby-identifier\">parse_signature</span>(<span class=\"ruby-string\">'double sum(double, ...\n</span></pre>\n"],["parse_struct_signature","DL::CParser","DL/CParser.html#method-i-parse_struct_signature","(signature, tymap=nil)","<p>Parses a C struct’s members\n<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">parse_struct_signature</span>([<span class=\"ruby-string\">'int i'</span>, <span class=\"ruby-string\">'char c'</span>])\n=<span class=\"ruby-operator\">&gt;</span> [[<span class=\"ruby-constant\">DL</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">TYPE_INT</span>, <span class=\"ruby-constant\">DL</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">TYPE_CHAR</span>], <span class=\"ruby-operator\">...</span>\n</pre>\n"],["ptr","DL::CFunc","DL/CFunc.html#method-i-ptr","()","<p>Get the underlying function pointer as a DL::CPtr object.\n"],["ptr","DL::CPtr","DL/CPtr.html#method-i-ptr","()","<p>Returns a DL::CPtr that is a dereferenced pointer for this DL::CPtr.\nAnalogous to the star operator in …\n"],["ptr=","DL::CFunc","DL/CFunc.html#method-i-ptr-3D","(p1)","<p>Set the underlying function pointer to a DL::CPtr named\n<code>pointer</code>.\n"],["realloc","DL","DL.html#method-c-realloc","(p1, p2)","<p>Change the size of the memory allocated at the memory location\n<code>addr</code> to <code>size</code> bytes.  Returns the memory …\n"],["ref","DL::CPtr","DL/CPtr.html#method-i-ref","()","<p>Returns a DL::CPtr that is a reference pointer for this DL::CPtr. Analogous\nto the ampersand operator …\n"],["remove_callback","DL","DL.html#method-i-remove_callback","(addr, ctype = nil)",""],["remove_callback_internal","DL","DL.html#method-i-remove_callback_internal","(proc_entry, addr_entry, addr, ctype = nil)",""],["remove_cdecl_callback","DL","DL.html#method-i-remove_cdecl_callback","(addr, ctype = nil)",""],["remove_stdcall_callback","DL","DL.html#method-i-remove_stdcall_callback","(addr, ctype = nil)",""],["set_callback","DL","DL.html#method-i-set_callback","(ty, argc, &cbp)",""],["set_callback_internal","DL","DL.html#method-i-set_callback_internal","(proc_entry, addr_entry, argc, ty, abi = nil, &cbp)",""],["set_cdecl_callback","DL","DL.html#method-i-set_cdecl_callback","(ty, argc, &cbp)",""],["set_ctypes","DL::CStructEntity","DL/CStructEntity.html#method-i-set_ctypes","(types)","<p>Given <code>types</code>, calculate the offsets and sizes for the types in\nthe struct.\n"],["set_ctypes","DL::CUnionEntity","DL/CUnionEntity.html#method-i-set_ctypes","(types)","<p>Given <code>types</code>, calculate the necessary offset and for each union\nmember\n"],["set_stdcall_callback","DL","DL.html#method-i-set_stdcall_callback","(ty, argc, &cbp)",""],["signed_value","DL::ValueUtil","DL/ValueUtil.html#method-i-signed_value","(val, ty)",""],["size","DL::CPtr","DL/CPtr.html#method-i-size","()","<p>Get the size of this pointer.\n"],["size","DL::CStructEntity","DL/CStructEntity.html#method-c-size","(types)","<p>Given <code>types</code>, returns the offset for the packed sizes of those\ntypes\n\n<pre>DL::CStructEntity.size([DL::TYPE_DOUBLE, ...</pre>\n"],["size","DL::CUnionEntity","DL/CUnionEntity.html#method-c-size","(types)","<p>Given <code>types</code>, returns the size needed for the union.\n\n<pre>DL::CUnionEntity.size([DL::TYPE_DOUBLE, DL::TYPE_INT, ...</pre>\n"],["size","DL::Packer","DL/Packer.html#method-i-size","()",""],["size","DL::Stack","DL/Stack.html#method-i-size","()",""],["size=","DL::CPtr","DL/CPtr.html#method-i-size-3D","(p1)","<p>Set the size of this pointer to <code>size</code>\n"],["sizeof","DL::Importer","DL/Importer.html#method-i-sizeof","(ty)",""],["struct","DL::Importer","DL/Importer.html#method-i-struct","(signature)","<p>Creates a class to wrap the C struct described by <code>signature</code>.\n\n<pre>MyStruct = struct ['int i', 'char c']</pre>\n"],["sym","DL::CompositeHandler","DL/CompositeHandler.html#method-i-sym","(symbol)",""],["sym","DL::Handle","DL/Handle.html#method-i-sym","(p1)","\n<pre>Document-method: []</pre>\n<p>Get the address as an Integer for the function named <code>name</code>.\n"],["sym","DL::Handle","DL/Handle.html#method-c-sym","(p1)","\n<pre>Document-method: []</pre>\n<p>Get the address as an Integer for the function named <code>name</code>.\n"],["to_i","DL::CFunc","DL/CFunc.html#method-i-to_i","()","<p>Returns the memory location of this function pointer as an integer.\n"],["to_i","DL::CPtr","DL/CPtr.html#method-i-to_i","()","<p>Returns the integer memory location of this DL::CPtr.\n"],["to_i","DL::Function","DL/Function.html#method-i-to_i","()",""],["to_i","DL::Handle","DL/Handle.html#method-i-to_i","()","<p>Returns the memory address for this handle.\n"],["to_int","DL::CPtr","DL/CPtr.html#method-i-to_int","()","<p>Returns the integer memory location of this DL::CPtr.\n"],["to_ptr","DL::CPtr","DL/CPtr.html#method-c-to_ptr","(p1)","<p>Get the underlying pointer for ruby object <code>val</code> and return it\nas a DL::CPtr object.\n"],["to_s","DL::CFunc","DL/CFunc.html#method-i-to_s","()","<p>Returns a string formatted with an easily readable representation of the\ninternal state of the DL::CFunc …\n"],["to_s","DL::CPtr","DL/CPtr.html#method-i-to_s","(p1 = v1)","<p>Returns the pointer contents as a string.  When called with no arguments,\nthis method will return the …\n"],["to_str","DL::CPtr","DL/CPtr.html#method-i-to_str","(p1 = v1)","<p>Returns the pointer contents as a string.  When called with no arguments,\nthis method will return the …\n"],["to_value","DL::CPtr","DL/CPtr.html#method-i-to_value","()","<p>Cast this CPtr to a ruby object.\n"],["typealias","DL::Importer","DL/Importer.html#method-i-typealias","(alias_type, orig_type)",""],["types","DL::Stack","DL/Stack.html#method-i-types","()",""],["unbind","DL::Function","DL/Function.html#method-i-unbind","()",""],["unbind_at_call","DL::Function","DL/Function.html#method-i-unbind_at_call","()",""],["unbind_at_call","DL::TempFunction","DL/TempFunction.html#method-i-unbind_at_call","()",""],["union","DL::Importer","DL/Importer.html#method-i-union","(signature)","<p>Creates a class to wrap the C union described by <code>signature</code>.\n\n<pre>MyUnion = union ['int i', 'char c']</pre>\n"],["unpack","DL::Packer","DL/Packer.html#method-i-unpack","(ary)",""],["unpack","DL::Stack","DL/Stack.html#method-i-unpack","(ary)",""],["unsigned_value","DL::ValueUtil","DL/ValueUtil.html#method-i-unsigned_value","(val, ty)",""],["value","DL::Importer","DL/Importer.html#method-i-value","(ty, val=nil)",""],["win32_last_error","DL::CFunc","DL/CFunc.html#method-c-win32_last_error","()","<p>Returns the last win32 error for the current executing thread\n"],["wrap_arg","DL::ValueUtil","DL/ValueUtil.html#method-i-wrap_arg","(arg, ty, funcs = [], &block)",""],["wrap_args","DL::ValueUtil","DL/ValueUtil.html#method-i-wrap_args","(args, tys, funcs, &block)",""],["wrap_result","DL::Function","DL/Function.html#method-i-wrap_result","(r)",""]]}}